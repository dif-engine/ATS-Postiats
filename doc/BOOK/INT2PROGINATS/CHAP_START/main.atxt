%{
//
dynload "libatsdoc/dynloadall.dats"
//
#include "./../ATEXT/int2proginats.dats"
//
%}\
#comment("\n\
The file is automatically generated by [atsdoc] from main.atxt.\n\
")
#comment("\n\
Time of Generation: #timestamp()\
")
<chapter
id="preparation_for_starting"
>
#langeng("
#title("Preparation for Starting")
")
#langja("
#title("はじめる前に")
")

#langeng("
#para("\

It is likely that you want to write programs in the programming language
you are learning.  You may also want to try some of the examples included
in this book and see what really happens. So I will first show you how to
write in ATS a single-file program, that is, a program contained in a
single file, and compile it and then execute it.\

")
")
#langja("
#para("\

おそらく、あなたはプログラミング言語を学習する際に何かプログラムを書きたくなるでしょう。
また、この本の見本のいくつかを試して、実際に起きることを目にしたいでしょう。
そこで、はじめにたった1つのファイルで構成されたプログラムをATSで書く方法を説明します。
その後、コンパイル方法と実行手順を説明します。\

")
")

<sect1
id="a_running_program"
>
#langeng("
#title("A Running Program")
")
#langja("
#title("実行可能なプログラム")
")

#langeng("
#para('\
The following example is a program in ATS that prints out (onto the
console) the string "Hello, world!" plus a newline before it terminates:

#atscode('\
val _ = print ("Hello, world!\\\n")

implement main0 () = () // a dummy for [main]
')

The keyword #dyncode("val") initiates a binding between the variable
#dyncode("_") (underscore) and the function call #dyncode('print ("Hello,
world!\\\n")').  However, this binding is never used after it is
introduced; its sole purpose is for the call to the #dyncode("print")
function to get evaluated.  ')#comment("para")
")
#langja("
#para('\

次の例は"Hello, world!"という文字列と改行をコンソールに印字するプログラムです。

#atscode('\
val _ = print ("Hello, world!\\\n")

implement main0 () = () // a dummy for [main]
')

#dyncode("val") キーワードは変数 #dyncode("_") (アンダースコア)に、
関数呼び出し #dyncode('print ("Hello, world!\\\n")') を束縛する。
この束縛は作られた後に使われるのではありません。
評価された時に、 #dyncode("print") 関数を呼び出すことが唯一の目的です。  ')#comment("para")
")

#langeng("
#para("\

The function #dyncode("main0") is a slight variant of another function
named #dyncode("main"), which is of certain special meaning in ATS. For a
programmer who knows the C or Java programming language, I simply point out
that the role of #dyncode("main") is essentially the same as its
counterpart of the same name in C or Java.  The keyword
#dyncode("implement") initiates the implementation of a function whose
interface has already been declared elsewhere. Following is the declared
interface for #dyncode("main0") in ATS:

#atscode("\
fun main0 (): void
")

which indicates that #dyncode("main0") is a nullary function, that is, a
function taking no arguments, and it returns no value (or it returns the
void value). The double slash symbol (#dyncode("//")) initiates a comment
that terminates at the end of the current line.\

")#comment("para")
")
#langja("
#para("\

#dyncode("main0") 関数はATSにおいて特殊な意味を持っていて #dyncode("main") 関数の変形です。
CやJava言語を知っているプログラマにとっては、
#dyncode("main") の役目はCやJavaにおける同じ名前の関数と本質的に同等であると言えるでしょう。
#dyncode("implement") キーワードは既に別の箇所でインターフェイスが宣言された関数の実装を作成します。

次に示すATSのソースコードは #dyncode("main0") に対するインターフェイスの宣言です。

#atscode("\
fun main0 (): void
")

このコードは #dyncode("main0") が引数を取らず返値がない関数であることを示しています。
返値がない、ということはvoid値を返すと言いかえることもできます。
#dyncode("//") から行末まではコメントです。 \

")#comment("para")
")

#para("\
Suppose that you have already installed the ATS programming language
system. You can issue the following command-line to generate an executable
named <filename>hello</filename> in the current working directory:

<informalexample><programlisting>
<command>atscc</command> -o hello hello.dats
</programlisting></informalexample>

where <filename>hello.dats</filename> refers to a file containing the above
program.  The command #command("atscc") is essentially a convenience
wrapper around the command #command("atsopt"), which triggers the process
of typechecking and compiling ATS programs. Note that #command("atscc") and
#command("atsopt") may actually be given the names #command("patscc") and
#command("patsopt"), respectively, in certain installations of ATS.  The filename
extension #emphasis(".dats") should not be altered as it has already been
assigned a special meaning that the compilation command #command("atscc")
recognizes. Another special filename extension is #emphasis(".sats"), which
we will soon encounter.\

")#comment("para")

</sect1><!--id="a_running_example"-->

<!-- ****** ****** -->

<sect1
id="a_template_for_single-file_programs"
>

#title("A Template for Single-File Programs")

#para("
The following code template, which is available
#mycodelink("CHAP_START/mytest.dats", "on-line"), is designed for constructing a
single-file program in ATS:

#atscode('\
(*
**
** A template for single-file ATS programs
**
*)

(* ****** ****** *)
//
\#include "share/atspre_define.hats"
\#include "share/atspre_staload.hats"
//
(* ****** ****** *)

//
// please write you program in this section
//

(* ****** ****** *)

implement main0 () = () // a dummy implementation for [main]

')#comment("atscode")

The line starting with the keyword #dyncode("\#include") enables the ATS
compiler #command("atsopt") to gain access to certain external library
packages and the definitions of various library functions. I will cover
elsewhere in the book the topic on making use of library in ATS.\

")#comment("para")

</sect1><!--id="a_template_for_single_file_programs"-->

<!-- ****** ****** -->

<sect1
id="a_makefile_template"
>
#title("A Makefile Template")

#para('\

The following Makefile template, which is available
#mycodelink("CHAP_START/Makefile_template", "on-line"), is provided to help
you construct your own Makefile for compiling ATS programs. If you are not
familiar with the #command("make") utility, you could readily find plenty
resources on-line to help yourself learn it.

#atscode('\
\#\#\#\#\#\#
\#
\# Note that
\# certain installations require the following changes:
\#
\# atscc -> patscc
\# atsopt -> patsopt
\# ATSHOME -> PATSHOME
\#
\#\#\#\#\#\#

ATSHOMEQ="$(ATSHOME)"

\#\#\#\#\#\#

ATSCC=$(ATSHOMEQ)/bin/atscc
ATSOPT=$(ATSHOMEQ)/bin/atsopt

\#\#\#\#\#\#

\#
\# HX: Please uncomment the one you want, or skip it entirely
\#
ATSCCFLAGS=
\#ATSCCFLAGS=-O2
\#
\# \'-flto\' enables link-time optimization such as inlining lib functions
\#
\#ATSCCFLAGS=-O2 -flto
\#

\#\#\#\#\#\#

cleanall::

\#\#\#\#\#\#

\#
\# Please uncomment the following three lines and replace the name [foo]
\# with the name of the file you want to compile
\#

\# foo: foo.dats ; \
\#   $(ATSCC) $(ATSCCFLAGS) -o $@ $< || echo $@ ": ERROR!!!"
\# cleanall:: ; $(RMF) foo

\#\#\#\#\#\#

\#
\# You may find these rules useful
\#

\# %_sats.o: %.sats ; $(ATSCC) $(ATSCCFLAGS) -c $< || echo $@ ": ERROR!!!"
\# %_dats.o: %.dats ; $(ATSCC) $(ATSCCFLAGS) -c $< || echo $@ ": ERROR!!!"

\#\#\#\#\#\#

RMF=rm -f

\#\#\#\#\#\#

clean:: ; $(RMF) *~
clean:: ; $(RMF) *_?ats.o
clean:: ; $(RMF) *_?ats.c

cleanall:: clean

\#\#\#\#\#\# end of [Makefile] \#\#\#\#\#\#
')#comment("atscode")
')#comment("para")

</sect1><!--id="a_makefile_template"-->

</chapter><!--"preparation_for_starting"-->

#comment(" ****** ****** ")

#comment(" end of [main.atxt] ")

%{
implement main () = fprint_filsub (stdout_ref, "main_atxt.txt")
%}

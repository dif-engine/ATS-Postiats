%{
//
dynload
"libatsdoc/dynloadall.dats"
//
#include "./../proginatsatxt.dats"
//
%}\
#comment("\n\
The file is automatically generated by [atsdoc] from main.atxt.\n\
")
#comment("\n\
Time of Generation: #timestamp()\
")
<chapter
id="abstract_views_viewtypes">
#title("Abstract Views and Viewtypes")

#para("\

I have so far given a presentation of views that solely focuses on at-views
and the views built on top of at-views. This is largely due to at-views
being the form of most widely used views in practice and also being the
first form of views supported in ATS. However, other forms of views can be
readily introduced into ATS abstractly. Even in a case where a view can be
defined based on at-views (or other forms of views), one may still want to
introduce it as an abstract view (accompanied with certain proof functions
for performing view changes). Often what the programmer really needs is to
figure out #emph("conceptually") whether abstractly defined views and proof
functions for manipulating them actually make sense. This is a bit like
arguing whether a function is computable: There is rarely a need, if at
all, to actually encode the function as a Turing-machine to prove its being
computable. IMHO, learning proper use of abstract views and abstract
viewtypes is a necessary step for one to take in order to employ linear
types effectively in practice to deal with resource-related programming
issues.

")

<sect1>
#title("Memory Allocation and Deallocation")

#para("\

The issue of memory allocation and deallocation is of paramount importance
in systems programming, where garabage collection (GC) at run-time is most
likely forbidden or only supported in a highly restricted manner.  Handling
memory management safely and efficiently is a long standing problem of
great challenge in programming, and its novel solution in ATS is firmly
rooted in the paradigm of programming with theorem-proving (PwTP).

")

#para('\

The following function #code("malloc_gc") is available in ATS for memory
allocation:

#atscode("\
fun malloc_gc ()
  {n:nat} (n: size_t n)
  :<> [l:agz] (freebyte_gc_v (n, l), b0ytes n @ l | ptr l)
// end of [malloc_gc]
")

The sort #code("agz") is a subset sort defined for addresses that are not
null:

#atscode("\
sortdef agz = {a:addr | a > null} // [gz] for great-than-zero
")

The type #code("b0ytes(n)") is a shorthand for #code("@[byte?][n]"), which
is for an array of #code("n") uninitialized bytes. Therefore, the at-view
#code("b0ytes(n)@l") is the same as the array-view #code("array_v(byte?, n,
l)").  The view #code("freebyte_gc_v(n, l)") stands for a form of
capability allowing that the #code("n") bytes located at the address
#code("l") be freed (or reclaimed) by the following function #code("free_gc"):

#atscode("\
fun free_gc {n:nat} {l:addr}
  (pfgc: freebyte_gc_v (n, l), pfat: b0ytes n @ l | p: ptr l):<> void
// end of [free_gc]
")

Note that #code("freebyte_gc_v") is so far the first view we have
encountered that is not built on top of any at-views.

')

#para('\

In practice, it is rather cumbersome to deal with bytes directly. Instead,
the following two functions are more convenient for allocating and
deallocating arrays:

#atscode('\
fun{a:viewt@ype}
array_ptr_alloc {n:nat} (asz: size_t n)
  :<> [l:agz] (free_gc_v (a?, n, l), array_v (a?, n, l) | ptr l)
// end of [array_ptr_alloc]

fun array_ptr_free
  {a:viewt@ype} {n:int} {l:addr} (
  pfgc: free_gc_v (a?, n, l), pfarr: array_v (a?, n, l) | p: ptr l
) :<> void // end of [array_ptr_free]
')

Given a type T, an integer N and an address L, the view
#code("free_gc_v")(T?, N, L) means that the memory for the array located at
L of N elements of the type T can be freed. In particular, the view
#code("freebyte_gc_v")(N, L) is just #code("free_gc_v")(#code("byte?"), N, L).

')

#para('\

I now give a realistic and interesting example involving both array
allocation and deallocation. The following two functions templates
#code("msort1") and #code("msort2") perform mergesort on a given array:

#atscode('\
typedef cmp (a:t@ype) = (&a, &a) -> int

extern
fun{a:t@ype}
msort1 {n:nat}
  (A: &(@[a][n]), n: size_t n, B: &(@[a?][n]), cmp: cmp(a)): void
// end of [msort1]

extern
fun{a:t@ype}
msort2 {n:nat}
  (A: &(@[a][n]), n: size_t n, B: &(@[a?][n]) >> @[a][n], cmp: cmp(a)): void
// end of [msort2]
')

It is well-known that merging two sorted segments of a given array requires
additional space. When #code("msort1") is called on arrays #code("A") and
#code("B"), the array #code("A") is the one to be sorted and the array
#code("B") is some kind of scratch area needed to perform merging (of
sorted array segments). When a call to #code("msort1") returns, the sorted
version of #code("A") is still sotred in #code("A"). What #code("msort2")
does is similar but the sorted version of #code("A") is stored in
#code("B") when a call to #code("msort2") returns.  As a good exercise, I
suggest that the interested reader take the effort to give a mutually
recursive implementation of #code("msort1") and #code("msort2").
An implementation of mergesort based on #code("msort1") can be readily
given as follows:

#atscode('\
extern
fun{a:t@ype}
mergesort {n:nat}
  (A: &(@[a][n]), n: size_t n, cmp: cmp(a)): void
// end of [mergesort]

implement{a}
mergesort (A, n, cmp) = let
  val (pfgc, pfat | p) = array_ptr_alloc<a> (n)
  val () = msort1 (A, n, !p, cmp)
  val () = array_ptr_free (pfgc, pfat | p)
in
  // nothing
end // end of [mergesort]
')

Clearly, an array is first allocated (to be used as a scratch area) and
then deallocated after it is no longer needed.

')

#para('\

The entire implementation of mergesort on arrays plus some testing code is
available #mycodelink("CHAPTER_ABSVTYPES/mergesort.dats", "on-line").

')

</sect1>

<sect1>
#title("Simple Linear Objects")
#para("\

Objects in the physical world are conspicuously linear: They cannot be
created from nothing or simply go vanished by turning into nothing. Thus,
it is only natural to assign linear types to values that represent physical
objects. I choose the name #emph("simple linear object") here to refer to a
linear value representing an object of some sort that does not contain
built-in mechanism for supporting inheritance.

")

#para("\
Let us first introduce a boxed abstract viewtype as follows
for simple linear objects:
")

#atscode('\
absviewtype sobjptr (a:viewt@ype+)
')

#para("\

Given a viewtype VT, #code("sobjptr(VT)") is essentially meant for a
pointer to some memory location L where a value of the viewtype VT is
stored. The following function template #code("sobjptr_new") and function
#code("sobjptr_free") are for creating and destroying (i.e., freeing) simple
linear objects, respectively:

")

#atscode('\
fun{a:viewt@ype} sobjptr_new (): sobjptr (a?)
fun sobjptr_free {a:t@ype} (x: sobjptr (a)): void
')

#para("\

The abstract viewtype #code("sobjptr") can be given the following
definition:

")

#atscode('\
assume
sobjptr (a:viewt@ype) = [l:addr] @{
  atview= a @ l, gcview= free_gc_v (a?, l), ptr= ptr l
} // end of [sobjptr]
')

#para("\
Subsequently, #code("sobjptr_new") and #code("sobjptr_free")
can be implemented as follows:
")

#atscode('\
implement{a}
sobjptr_new () = let
  val (pfgc, pfat | p) = ptr_alloc<a> ()
in @{
  atview= pfat, gcview= pfgc, ptr= p
} end // end of [sobjptr_new]

implement
sobjptr_free {a} (pobj) =
  ptr_free (pobj.gcview, pobj.atview | pobj.ptr)
// end of [sobjptr_free]
')

#para("\

Clearly, a simple object needs to be initialized before
it is of any use. This can be done by calling the following
function #code("sobjptr_init"):

")

#atscode('\
extern
fun sobjptr_init {a:viewt@ype}
  (pobj: !sobjptr (a?) >> sobjptr (a), f: (&a? >> a) -> void): void
// end of [sobjptr_init]

implement
sobjptr_init
  (pobj, f) = let
  prval pfat = pobj.atview
  val () = f !(pobj.ptr)
  prval () = pobj.atview := pfat
in
  // nothing
end // end of [sobjptr_init]
')

#para("\

As a simple object may contain resources, it needs to be cleared out before
it is allowed to be freed. This can be done by calling the following
function #code("sobjptr_clear"):

")

#atscode('\
extern
fun sobjptr_clear
  {a:viewt@ype} (
  x: !sobjptr (a) >> sobjptr (a?), f: (&a >> a?) -> void
) : void // end of [sobjptr_clear]

implement
sobjptr_clear
  (pobj, f) = let
  prval pfat = pobj.atview
  val () = f !(pobj.ptr)
  prval () = pobj.atview := pfat
in
  // nothing
end // end of [sobjptr_clear]
')

#para("\

Note that each type T (of the sort #code("t@ype")) is a subtype of T?,
implying that #code("sobjptr")(T) is a subtype of #code("sobjptr")(T?)  (as
#code("sobjptr") is co-variant). Therefore, #code("sobjptr_free") can be
called directly on a value of the type #code("sobjptr")(T) without need to
call #code("sobjptr_clear") on the value first.

")

#para("

Let us now see a concrete example of simple linear object. Suppose that a
timer (that is, stopwatch) is wanted to measure time (of some
sort). Following is a natural interface for functions creating, destroying
and manipulating timer objects:

")

#atscode('\
absviewtype timerObj

fun timerObj_new (): timerObj
fun timerObj_free (x: timerObj): void
fun timerObj_start (x: !timerObj): void
fun timerObj_finish (x: !timerObj): void
fun timerObj_pause (x: !timerObj): void
fun timerObj_resume (x: !timerObj): void
fun timerObj_get_ntick (x: !timerObj): uint
fun timerObj_reset (x: !timerObj): void
')

#para('\

The (flat) record type #code("timer_struct") is defined as follows to
represent the state of a timer object:

')

#atscode('\
typedef
timer_struct = @{
  started= bool // the timer has started
, running= bool // the timer is running
  // the tick number recorded
, ntick_beg= uint // when the timer was turned on the last time
, ntick_acc= uint // the number of accumulated ticks
} // end of [timer_struct]
')

#para('\

The abstract viewtype #code("timerObj") can then be mapped to
#code("sobjptr(timer_struct)"):

')

#atscode('\
assume timerObj = sobjptr (timer_struct)
')

#para('\

The functions #code("timerObj_new") and #code("timerObj_free")
can now be given the following implementation:

')

#atscode('\
implement
timerObj_new () = let
  typedef T = timer_struct
  fn f (
    x: &T? >> T
  ) : void = {
    val () = x.started := false
    val () = x.running := false
    val () = x.ntick_beg := 0u // unsigned
    val () = x.ntick_acc := 0u // unsigned
  } // end of [f]
  val pobj = sobjptr_new<T> ()
in
  sobjptr_init {T} (pobj, f); pobj
end // end of [timerObj_new]

implement
timerObj_free (pobj) = sobjptr_free (pobj)
')

#para("\

For brevity, I omit the code implementing the other functions on timer
objects, which the interested reader can find
#mycodelink("CHAPTER_ABSVTYPES/sobjptr.dats", "on-line") together with
some additional testing code.

")

</sect1>

<sect1>
#title("Example: Implementing an Array-Based Circular Buffer")

#para("\

Array-based circular buffers (of fixed sizes) are of common use in
practice. For instance, in a typical client/server model, a circular buffer
can be employed to hold requests issued by multiple clients that are then
processed by the server according to the first-in-first-out (FIFO)
policy. In a case where each request needs to be given a priority (chosen
from a fixed set), a circular buffer can be created for each priority to
hold requests assigned that priority.

")

#para("\

I first declare a linear abstract type (that is, abstract viewtype) as
follows for values representing circular buffers:

")

#atscode('\
absviewtype cbufObj (a:viewt@ype+, m:int, n: int)
')

#para("\

Such values are considered simple linear objects (as inheritance is not an
issue to be dealt with in this setting). Given a viewtype VT and two
integers M and N, the viewtype #code("cbufObj")(VT, M, N) is for a given
buffer of maximal capacity M that currently contains N elements of the type
VT.

")

#para("\
Some properties on the parameters of #code("cbufObj") can be captured
by introducing the following proof function:
")

#atscode('\
prfun cbufObj_param_lemma
  {a:viewt@ype} {m,n:int} (buf: !cbufObj (a, m, n)): [m>=n; n>=0] void
// end of [cbufObj_param_lemma]
')

#para("\

The interface for the following two function templates indicates that they
can be called to compute the capacity and current size of a buffer:

")

#atscode('\
fun{a:viewt@ype}
cbufObj_get_cap
  {m,n:int} (
  buf: !cbufObj (a, m, n)
) : size_t (m) // end of [cbufObj_get_cap]

fun{a:viewt@ype}
cbufObj_get_size
  {m,n:int} (
  buf: !cbufObj (a, m, n)
) : size_t (n) // end of [cbufObj_get_size]
')

#para("\

While it is straightforward to use #code("cbufObj_get_cap") and
#code("cbufObj_get_size") to tell whether a buffer is currently empty or
full, a direct approach is likely to be more efficient. The following two
function templates check for the emptiness and fullness of a given circular
buffer:

")

#atscode('\
fun{a:viewt@ype}
cbufObj_is_empty
  {m,n:int} (buf: !cbufObj (a, m, n)): bool (n==0)

fun{a:viewt@ype}
cbufObj_is_full
  {m,n:int} (buf: !cbufObj (a, m, n)): bool (m==n)
')

#para("\

The functions for creating and destroying circular buffers are named
#code("cbufObj_new") and #code("cbufObj_free"), respectively:

")

#atscode('\
fun{a:viewt@ype}
cbufObj_new {m:pos} (m: size_t m): cbufObj (a, m, 0)

fun cbufObj_free
  {a:viewt@ype} {m:int} (buf: cbufObj (a, m, 0)): void
// end of [cbufObj_free]
')

#para("\

Note that a buffer can be freed only if it contains no elements as
an element (of some viewtype) may contain resources. If elements in
a buffer are of some (non-linear) type, then the following function
can be called to clear out all the elements stored in the buffer:

")

#atscode('\
fun cbufObj_clear_type
  {a:t@ype} {m:int} (
  buf: !cbufObj (a, m, n) >> cbufObj (a, m, 0)
) : void // end of [cbufObj_clear_type]
')

#para("\

The next two functions are for inserting/removing an element into/from a
given buffer, which are probably the most frequently used operations on
buffers:

")

#atscode('\
fun{a:viewt@ype}
cbufObj_insert
  {m,n:int | n < m} (
  buf: !cbufObj (a, m, n) >> cbufObj (a, m, n+1), x: a
) : void // end of [cbufObj_insert]

fun{a:viewt@ype}
cbufObj_remove
  {m,n:int | n > 0} (
  buf: !cbufObj (a, m, n) >> cbufObj (a, m, n-1)
) : a // end of [cbufObj_remove]
')


#para("\

Please find on-line the file
#mycodelink("CHAPTER_ABSVTYPES/circbuf.sats", "circbuf.sats")
containing the
entirety of the interface for functions creating, destroying
and manipulating circular buffers.

")

#para("\

There are many simple and practical ways to implement the abstract type
#code("cbufObj") and the functions declared in
#mycodelink("CHAPTER_ABSVTYPES/circbuf.sats", "circbuf.sats").  In the
on-line file #mycodelink("CHAPTER_ABSVTYPES/circbuf.dats", "circbuf.dats"),
I give an implementation that employs four pointers p_beg, p_end, p_frst
and p_last to represent a circular buffer: p_beg and p_end are the starting
and finishing addresses of the underline array, respectively, and p_frst
and p_last are the starting addresses of the occupied and unoccupied
segments (in the array), respectively. What is special about this
implementation is its employing a style of programming that deliberately
eschews the need for proof construction. While code written in this style is
not guaranteed to be type-safe, the style can nonetheless be of great
practical value in a setting where constructing formal proofs is deemed too
costly a requirement to be fully fulfilled. Anyone who tries to give a
type-safe implementation for the functions declared in
#mycodelink("CHAPTER_ABSVTYPES/circbuf.sats", "circbuf.sats") should likely
find some genuine appreciation for this point.

")

#para("\

In the on-line file #mycodelink("CHAPTER_ABSVTYPES/circbuf2.dats",
"circbuf2.dats"), I give another implementation in which a circular buffer
is represented as a pointer p_beg plus three integers m, n and f: p_beg
points to the starting location of the underline array, m is the size of
the array (that is, the capacity of the buffer), n is the number of
elements currently stored in the buffer and f is the total number of
elements that have so far been removed from the buffer. Again, proof
construction is delibrately eschewed in this implementation.

")

</sect1>

<sect1>
#title("From linearity to non-linearity")
#para("")
</sect1>

</chapter><!--id="abstract_views_viewtypes"-->

#comment(" ****** ****** ")
#comment(" end of [main.atxt] ")

%{
implement main () = fprint_filsub (stdout_ref, "main_atxt.txt")
%}
